## 📋 기능 수행 로직

#### 다리길이 입력

- OutputView 시작 문구 출력.
- InputView.readBridgeSize 사용자에게 다리의 길이를 입력받음.
- Controller에게 다리 길이 를 전달.
- ✔️ 예외 처리 확인.
- Controller 는 다리 길이 정보를 BridgeGame에 전달.
- BridgeGame은 BridgeMaker, BridgeRandomNumberGenerate 사용해서 다리 만들기.
- 만들어진 다리 정보 저장.

#### 움직임 입력

- InputView.readMoving 사용자에게 움직임을 입력받음.
- Controller 에게 움직일 방향 전달.
- ✔️ 예외 처리 확인.
- Controller 는 움직일 방향을 BridgeGame에 전달.
- move 메소드가 이동할 정보를 모델 내에서 확인. 이후 확인값 Controller 에게 전달.
- Controller는 이동정보를 OutView에게 전달.
- OutView는 맞는 정보에 맞게 출력
- 이후 move 메소드는 게임 진행상황을 Controller 에게 전달.
- Controller는 진행 상황을 OutputView에게 출력하라 명령.
- OutputView는 전달받은 정보로 진행 상황 출력.
- 이후, 함정을 밟았는지에 대한 정보를 확인.

  - 함정을 안밟은 경우
  - 다리 끝까지 혹은 함정을 밟을때까지 InputView.readMoving 과정을 반복

  - 함정을 밟은 경우
  - Controller는 InputView.readGameCommand를에게 게임 재시작 응답을 입력받게 명령.
  - 응답정보를 Controller 에게 알려줌.
  - ✔️ 예외 처리 확인.
  - Controller 는 응답정보를 BridgeGame에게 전달.
  - BrideGame 은 응답 정보에 맞는 값을 Controoler 에게 전달.

#### 재시작

- BridgeGame은 현재까지 온 스테이지 번호를 다시 초기화, 기존 다리 정보는 유지됨.
- BridgeGame 은 재시작 횟수 를 카운트.
- Controller는 inputView.readMoving 을 재실행.

#### 종료

- Controller는 현재까지의 게임 정보를 BridgeGame에게 요구.
- BridgeGame은 현재까지의 게임 정보를 Controller에게 전달
- Controller는 OutputView.printResult 에게 현재까지의 게임 정보를 전달
- OutputView.printResult는 전달 받은 게임 정보에 맞는 결과 출력.
- 게임 종료.

### 게임 클리어

- Controller에게 게임이 완료되었다는 정보가 전달된다.
- Controller는 게임을 종료시키라는 명령을 내린다.
- GameBridge에게 현재까지 이뤄진 게임 정보를 요구해서 받아낸다.
- OutputView.printResult는 전달 받은 게임 정보에 맞는 결과 출력.
- 게임 종료. <br>
  <br>

## 📋 [javascript-bridge] 미션

- 📋 [다리 건너기 미션 기능목록](https://github.com/soohyun-dev/javascript-bridge/tree/soohyun-dev/docs)
  <br>

## 💁‍♂️ 4주차 과제는 이것이 좋았다!

### 🔵 MVC 패턴 적용

이번 미션은 MVC 패턴을 적용하여 풀었습니다. View 객체들과 BridgeGame 클래스가 주어진 이유와 각 기능들에 대한 요구사항들에 대해 생각해보았습니다. View는 입력과 출력만을 담당하는 UI 로직에 대한 일만 하고 있으며, BridgeGame은 데이터를 관리하고 실행하며, 값과 값에 대한 기능들을 하는 비즈니스 로직에 대한 일만 하고 있다고 생각이 들었습니다. 또한, BridgeGame에서 InputView와 OutputView 를 사용할 수 없다고 제한된 점이 가장 큰 힌트였다고 생각했고 이는 곧 'MVC 패턴에서 Model과 View는 Controller의 중재를 통해서만 정보를 주고 받을 수 있다'는 점에 부합하였습니다. 따라서, MVC 패턴을 적용하기에 적절한 요구사항이라 판단하였습니다. 처음 공부하고 적용해보는 부분이라 낯설고 어려웠기에 이전보다 더 많은 공부가 필요했습니다. 한 눈에 들어오도록 PPT로 정리해보며 MVC 패턴과 로직 이해를 위해 노력했습니다. 제가 학습한 내용들을 적용해 이번 미션의 파일구성과 기능들의 역할을 나누어보는 연습을 하며 구현하였고 MVC 패턴과 코드로 구현하는 것에 대한 이해도가 높아지게 된 유익한 미션이었습니다. <br>
<br>

### 🔵 단일 책임 원칙 지키기

이번 미션에서 가장 신경 썼던 부분입니다. 이전 미션들에서 함수(메소드) 분리, 클래스 분리들을 하면서 익혀두었던 `한가지 일만 수행한다`라는 부분에 초점을 두었습니다. Model과 View, Controller들이 하는 일에 집중해 크게 나누었고, 나누어진 클래스와 객체들이 가지고 잇는 메소드들은 한 가지 일만 수행하도록 쪼개었습니다. <br>
<br>

### 🔵 유효성 검사는 어느 부분에서? 에 대한 고민.

단일 책임 원칙을 지키면서 헷갈리는 부분이 있었다면, 유효성 검사를 하는 부분이였습니다. View에서 입력받은 값을 Controller에서 유효성을 검사해야하는지, Model로 보낸 뒤 Model에서 유효성을 검사하는 지에 대한 고민이 있었습니다.우선, 저는 Cotroller는 정상적인 값만 전달해주고, Model은 비즈니스 로직에만 신경을 쓰는 것이 맞는다고 생각해서 Controller로 구분하였습니다. <br><br>
[📌 In MVC should a model handle validation?](https://softwareengineering.stackexchange.com/questions/97880/in-mvc-should-a-model-handle-validation)<br>
[📌 Where do you do your validation? model, controller or view](https://stackoverflow.com/questions/134388/where-do-you-do-your-validation-model-controller-or-view)<br>
[📌 MVC(Model-View-Controller)](https://medium.com/@jinhyuk.b/mvc-f31786d80171)<br>
<br>
이후, 저의 생각과 위의 자료들을 같이 읽어가면서 비교하며 방향을 잡았습니다. 의외로 의견들이 갈리는 부분들이 흥미로웠습니다. 이런 저런 의견들이 많았지만, 종합해보고 스스로 고민해본 결과 Controller에서 유효성 검사를 진행한 뒤 유효한 값을 Model에 넘겨 Model의 데이터 무결성을 보장에 도움이 되도록 코드를 구현하였습니다. Controller는 "입력된 값이 정상적인 값인가?"에 대한 기능을 수행하는 부분이고, Model에서는 "전달된 값이 어떤 의미가 있는 값인가?"에 대한 기능을 수행하는 부분이라 판단하였기 때문입니다. <br>
<br>
하지만, 팀프로젝트나 실무에서는 전달된 값을 맹신하지말고 모든 layer에서 유효성 검사를 해야한다는 의견들도 얻을 수 습니다. 누구나 실수할 수 있고, 내가 작성하지 않은 코드에서 오는 데이터를 무작정 신뢰할 수는 없기 때문입니다. 하지만, 이번 미션만큼은 저 혼자 모든 기능을 구현하는 것이므로 Controller가 전달하는 값에 대한 신뢰도가 상대적으로 높다고 판단하였기때문에 Controller에서만 유효성 검사를 실행하였습니다. <br>
<br>
앞으로도 계속해서 고민해보면서 구현에 신경을 써야할 부분이라 생각하며, 깊은 고민을 갖게한 흥미로운 주제였습니다. <br>
<br>

### 🔵 getter 기능을 최소화한다.

getter 기능을 최소화하라는 뜻은 `상태 데이터를 꺼내 로직을 처리하도록 구현하지 말고 객체에 메시지를 보내 일을 하도록 리팩토링한다.`를 최대한 지키기 위함이였습니다. 이번 미션에서는 마지만 결과값을 출력할 메소드 기능만을 위해서만 Map정보와 게임 시도 횟수의 데이터를 꺼내왔고, 이외의 모든 기능들에서는 데이터를 가지는 객체가 일을 하도록 명령하였습니다. 불필요한 데이터를 불러오는 일들을 줄이고<br>
<br>

### 🔵 테스트 코드도 코드다.

이번 미션에서도 테스트 코드를 작성해가면서 구현한 코드에 대한 신뢰도를 높혀갔습니다. 리팩터링에 특히 신경써야하는 미션인 만큼 테스트 코드도 잘 갖춰져있어야 리팩터링으로 예기치 못한 오류 발생시 바로 캐치할 수 있었습니다. 여태까지는 테스트코드에 대한 리팩터링에 미숙했습니다. 중복된 코드가 많아도 테스트 코드라는 이유로 '테스트 코드이니 돌아가면 됐지' 라는 생각으로 다른 부분들에 집중했습니다. 3주차 피드백을 통해서 테스트 코드에 대해 다시 생각해볼 수 있었고, 이번 미션에서는 이전보다 중복된 값들을 줄이고 효율적으로 테스트코드를 작성하려 노력했습니다.<br>

<br>

## 😊 4주차 과제를 진행한 소감

어느덧 프리코스의 마지막 주입니다. 너무 너무 아쉽습니다... 매주 미션들을 수행하며 배우는 것들이 많았기에 지난 한달이 너무 유익한 시간들이었습니다. 한 달동안 프리코스에 매진하며 매주차 코드들이 나아지는 것을 느꼈고 제 힘으로 기능들을 구현하고 실행하며 여러 테스트들을 통과시키는 모든 과정들이 너무 재밌었습니다. 자바스크립트 클래스를 다루는 부분에서 특히 엄청난 성장이 이뤄졌습니다. 프리코스를 시작하기 전 매일 알고리즘 풀이에만 매진했던 제가 프리코스를 통해 여러 기능들을 만들어보고 동작하게 하는 미션들을 해보면서 처음엔 어려웠던 부분들이 날이 갈수록 익숙해졌고, 더 많은 것들을 다룰수 있게 만들어 주었습니다. 코드를 쓰는 방법들을 배우고, 메소드를 효율적으로 생성하고 사용하는 법들을 익히면서 1,2,3주차를 거듭할수록 점점 제가 작성한 코드들이 나아지는 것이 느껴졌고, 제 힘으로 기능들을 구현하여 테스트를 통과시키게 하는 모든 과정들이 너무 재미있고 뜻 깊었습니다. 학습적으로도 유익한 시간이었으나 우테코 프리코스를 끝까지 달렸다는 자체로도 자부심이 되었습니다. 매주차 알게된 실수들과 더 나은 방법들이 쌓였고 초점을 맞추어 코드를 짜볼 수 있었습니다. 이러한 과정이 쌓이면 습관이 된다고 생각합니다. 여태까지 제출한 저의 코드들이 모두 만족스러운 것은 아니지만, 최선을 다해 임했다고는 말할 수 있습니다. 1차 통과를 한다면 '잘 해온게 맞구나' 느껴 감격스럽고 앞으로의 동기가 되겠지만 꼭 최종통과까지 이어져 우테코와 함께 성장할 수 있는 시간들을 만들어가고 싶습니다. 혼자 해나간 프리코스에서도 얻은 것이 많고 즐거웠지만 같은 과정을 거치고 같은 열정을 가진 크루원들을 만나 함께 해나아가는 과정이 얼마나 재미있고 유익할지 기대가 됩니다. 만나게될 크루원들 사이에서 실력적 부분에서 1등이 되지 못하더라도 시간과 노력으로 꼭 앞서겠습니다. 순식간에 지나간 지난 4주동안 주신 기회와 피드백들에 정말 감사드립니다. 😚 <br>
<br><br>
